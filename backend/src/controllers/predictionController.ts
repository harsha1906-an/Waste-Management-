import { Request, Response, NextFunction } from "express";
import axios from "axios";
import Prediction from "../models/Prediction";
import Product from "../models/Product";

interface AuthRequest extends Request {
  user?: {
    userId: string;
    role: string;
  };
}

const ML_SERVICE_URL = process.env.ML_SERVICE_URL || "http://localhost:8000";

export const predictionController = {
  // Request a forecast for a product
  async requestForecast(req: AuthRequest, res: Response, next: NextFunction) {
    try {
      const { productId, days = 7 } = req.body;
      const vendorId = req.user?.userId;

      if (!productId) {
        return res.status(400).json({ error: "Product ID is required" });
      }

      if (!vendorId) {
        return res.status(401).json({ error: "Unauthorized" });
      }

      // Verify product belongs to vendor
      const product = await Product.findByPk(productId);
      if (!product) {
        return res.status(404).json({ error: "Product not found" });
      }

      if (product.vendorId !== vendorId) {
        return res.status(403).json({ error: "Not authorized to forecast this product" });
      }

      console.log(`[Prediction] Requesting forecast from ML service for product ${productId}`);

      // Call ML service
      const mlResponse = await axios.post(
        `${ML_SERVICE_URL}/predict`,
        {
          product_id: productId,
          days: Math.min(days, 30), // Cap at 30 days
          include_confidence: true,
        },
        { timeout: 30000 }
      );

      const { predictions, model_used, accuracy_score, recommendations, metadata } = mlResponse.data;

      // Store predictions in database
      for (const pred of predictions) {
        await Prediction.create({
          id: undefined, // Will be auto-generated by UUID
          productId,
          vendorId,
          forecastDate: pred.date,
          predictedQuantity: pred.predicted_quantity,
          confidenceLevel: pred.confidence_level,
          modelUsed: model_used,
          recommendations: recommendations || [],
        } as any);
      }

      // Return the original ML response format for frontend
      res.json({
        data: {
          predictions, // Original format with date, predicted_quantity, etc.
          modelUsed: model_used,
          accuracyScore: accuracy_score,
          recommendations,
          metadata,
          generatedAt: new Date().toISOString(),
        },
      });
    } catch (error) {
      console.error("[Prediction] Error:", error);
      if (axios.isAxiosError(error)) {
        if (error.response?.status === 503) {
          return res.status(503).json({ error: "ML service temporarily unavailable" });
        }
        return res.status(error.response?.status || 500).json({
          error: error.response?.data?.detail || "Failed to generate forecast",
        });
      }
      next(error);
    }
  },

  // Get stored predictions for a product
  async getPredictions(req: AuthRequest, res: Response, next: NextFunction) {
    try {
      const { productId } = req.params;
      const vendorId = req.user?.userId;

      if (!vendorId) {
        return res.status(401).json({ error: "Unauthorized" });
      }

      // Verify product belongs to vendor
      const product = await Product.findByPk(productId);
      if (!product) {
        return res.status(404).json({ error: "Product not found" });
      }

      if (product.vendorId !== vendorId) {
        return res.status(403).json({ error: "Not authorized to view predictions" });
      }

      const predictions = await Prediction.findAll({
        where: {
          productId,
          vendorId,
        },
        order: [["forecastDate", "ASC"]],
      });

      res.json({
        data: predictions,
        count: predictions.length,
      });
    } catch (error) {
      next(error);
    }
  },

  // Get predictions for all vendor products
  async getVendorPredictions(req: AuthRequest, res: Response, next: NextFunction) {
    try {
      const vendorId = req.user?.userId;

      if (!vendorId) {
        return res.status(401).json({ error: "Unauthorized" });
      }

      const predictions = await Prediction.findAll({
        where: {
          vendorId,
        },
        include: [
          {
            model: Product,
            as: "product",
            attributes: ["id", "name", "category", "quantity"],
          },
        ],
        order: [["createdAt", "DESC"]],
      });

      res.json({
        data: predictions,
        count: predictions.length,
      });
    } catch (error) {
      next(error);
    }
  },

  // Get ML model information
  async getModelInfo(req: AuthRequest, res: Response, next: NextFunction) {
    try {
      console.log("[Prediction] Fetching model info from ML service");

      const mlResponse = await axios.get(`${ML_SERVICE_URL}/models`, {
        timeout: 5000,
      });

      res.json({
        data: mlResponse.data.models,
      });
    } catch (error) {
      console.error("[Prediction] Error fetching models:", error);
      if (axios.isAxiosError(error)) {
        return res.status(error.response?.status || 503).json({
          error: "Failed to fetch model information",
        });
      }
      next(error);
    }
  },

  // Get ML service metrics
  async getMetrics(req: AuthRequest, res: Response, next: NextFunction) {
    try {
      const mlResponse = await axios.get(`${ML_SERVICE_URL}/metrics`, {
        timeout: 5000,
      });

      res.json({
        data: mlResponse.data,
      });
    } catch (error) {
      console.error("[Prediction] Error fetching metrics:", error);
      if (axios.isAxiosError(error)) {
        return res.status(error.response?.status || 503).json({
          error: "Failed to fetch metrics",
        });
      }
      next(error);
    }
  },

  // Batch request forecasts for multiple products
  async batchRequestForecast(req: AuthRequest, res: Response, next: NextFunction) {
    try {
      const { productIds, days = 7 } = req.body;
      const vendorId = req.user?.userId;

      if (!Array.isArray(productIds) || productIds.length === 0) {
        return res.status(400).json({ error: "Product IDs array is required" });
      }

      if (!vendorId) {
        return res.status(401).json({ error: "Unauthorized" });
      }

      console.log(`[Prediction] Batch forecast for ${productIds.length} products`);

      // Call ML service batch endpoint
      const mlResponse = await axios.post(
        `${ML_SERVICE_URL}/predict/batch`,
        {
          product_ids: productIds,
          days: Math.min(days, 30),
        },
        { timeout: 60000 }
      );

      const predictions = mlResponse.data.predictions || [];

      // Store all predictions
      const allPredictions = [];
      for (const pred of predictions) {
        for (const forecastPoint of pred.predictions || []) {
          const prediction = await Prediction.create({
            id: undefined, // Will be auto-generated by UUID
            productId: pred.product_id,
            vendorId,
            forecastDate: forecastPoint.date,
            predictedQuantity: forecastPoint.predicted_quantity,
            confidenceLevel: forecastPoint.confidence_level,
            modelUsed: pred.model_used,
            recommendations: pred.recommendations || [],
          } as any);
          allPredictions.push(prediction);
        }
      }

      res.json({
        data: {
          predictions: allPredictions,
          productCount: productIds.length,
          forecastCount: allPredictions.length,
          generatedAt: new Date().toISOString(),
        },
      });
    } catch (error) {
      console.error("[Prediction] Batch error:", error);
      if (axios.isAxiosError(error)) {
        return res.status(error.response?.status || 500).json({
          error: error.response?.data?.detail || "Batch forecast failed",
        });
      }
      next(error);
    }
  },
};
